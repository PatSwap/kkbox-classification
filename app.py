# -*- coding: utf-8 -*-
"""Untitled17.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pInl_j5DQJosleOp2i6W2wKy-wRoE0Hp
"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.tree import DecisionTreeClassifier
from pickle import load
import joblib
import datetime
import time

st.set_page_config(
    page_title="Music Rec",
    layout="wide",
    menu_items={
        "About": """
        Hope you like this app!
        Made by Swapnil Patil (https://github.com/PatSwap)
        """,
        "Get Help": "https://twitter.com/brugsby",
        "Report a Bug": "https://github.com/PatSwap/kkbox-music-rec/issues",
    },
)

model = joblib.load(r'dt.joblib')

numeric   = ['bd','song_length','artist_count', 'comp_count', 'lyric_count',
             'genre_count', 'day_diff', 'reg_year', 'reg_month', 'reg_day',
             'reg_weekday', 'reg_week', 'exp_year', 'exp_month', 'exp_day',
             'exp_weekday', 'exp_week', 'primary_genre', 'secondary_genre',
             'tertiary_genre', 'ref_year']

# Making a list of the categorical features with no ordinal relation

categoric = ['source_system_tab', 'source_screen_name', 'source_type',
             'gender','city','registered_via','language']

shortlist = pd.read_csv(r'shortlist.csv')

artists = ['BLACKPINK', 'Kodaline', 'Coldplay', 'The Weeknd', 'BANGTAN BOYS',
       'Sammi Cheng', 'Angeline Wong', 'Taylor Swift',
       'Sugar Eyes', 'Edward Chen', 'Fang Shun Ji',
       'Ming Bridges', 'Park Heykyoung',
       'Jolin Tsai', 'Cake Poonyamund', 'Amit Trivedi',
       'A.R.Rahman',
       'Kishore Kumar', 'Super 4']

j = 0
temp_dict = dict()
for i in artists:
  temp_dict[i] = j
  j += 1
shortlist.drop(['song_id','artist_name','composer','lyricist','genre_ids',], axis=1, inplace=True)

main_dict = dict()
for i in categoric:
  path    = r'encoder'+i+'.pkl'
  encoder =  load(open(path, 'rb'))
  main_dict[i] = list(encoder.classes_)

@st.cache
def predict(df):
  pred = model.predict(df)
  if pred[0] < 0.50:
    return('The Song should not be recommended')
  else:
    return('The Song should be recommended')

st.title('Music Recommendation App')
with st.expander(label="What's the challenge?", expanded=True):
    st.info(
        """
        This app will predict if you will listen to previously listened song based on two things:
        1. Information about your usage of the app
        2. Statistics about the song from the dataset
        3. The app uses a form to collect this info and generates a single prediction based on it 
        """
    )

with st.expander(label="How to generate a prediction"):
    st.write(
        """
        1. From the left hand sidebar, choose an artist of your choice
        (The dataset contains hundreds of artists but for now we will use a famous few from around the world)\n
        2. Fill in the form with information about you (age, membership dates) and about how you discovered the song\n
        3. Click on Predict and voila! The app will predict if you will listen to the song again or not
        """
    )

st.sidebar.header('List of Artists')
st.subheader('Please fill in the fields below')
def main():

  def user_input():
    artist  = st.sidebar.radio(label ='Choose the artist whose song you\'ve listened to', options= list(temp_dict.keys()))
    x  = temp_dict.get(artist)
    df = shortlist.iloc[[x]]


    date_min = datetime.datetime.strptime('01/01/04', '%d/%m/%y')
    reg_date = st.date_input(label='When did you register for the subscription',
                           min_value=date_min,)
    exp_date = st.date_input(label='When did your subscription expire?',
                           min_value=date_min,)
    source_system_tab = st.selectbox(label = 'Choose the name of the tab where the song was played',
                                   options = main_dict.get('source_system_tab'),
                                   index=0,)
    source_screen_name = st.selectbox(label = 'Choose the layout you in which the song was played',
                                    options = main_dict.get('source_screen_name'),
                                    index=0,)
    source_type = st.selectbox(label = 'What was your entry point when you first played the song',
                             options = main_dict.get('source_type'),
                             index=0,)
    city = st.selectbox(label = 'Which city do you live in?',
                      options = main_dict.get('city'),
                      index=0,)
    gender = st.radio(label = 'Please choose your gender',
                    options = main_dict.get('gender'),
                    index=2)
    registered_via = st.selectbox(label = 'Choose your registration method',
                                options = main_dict.get('registered_via'),
                                index=0,)
    age = st.slider('How old are you?', 10, 90, 25)


    datapoint = pd.DataFrame({
        'source_system_tab':source_system_tab,
        'source_screen_name':source_screen_name,
        'source_type':source_type,
        'city':city,
        'bd':age,
        'gender':gender,
        'registered_via':registered_via,
        'day_diff':(exp_date - reg_date).days,
        'reg_year':reg_date.year,
        'reg_month':reg_date.month,
        'reg_day':reg_date.day,
        'reg_weekday':reg_date.weekday(),
        'reg_week':reg_date.isocalendar()[1],
        'exp_year':exp_date.year,
        'exp_month':exp_date.month,
        'exp_day':exp_date.day,
        'exp_weekday':exp_date.weekday(),
        'exp_week':exp_date.isocalendar()[1],
        'ref_year':df.iloc[0]['ref_year'],
        'song_length':df.iloc[0]['song_length'],
        'language':df.iloc[0]['language'],
        'artist_count':df.iloc[0]['artist_count'],
        'comp_count':df.iloc[0]['comp_count'],
        'lyric_count':df.iloc[0]['lyric_count'],
        'genre_count':df.iloc[0]['genre_count'],
        'primary_genre':df.iloc[0]['primary_genre'],
        'secondary_genre':df.iloc[0]['secondary_genre'],
        'tertiary_genre':df.iloc[0]['tertiary_genre']}, index = [0])
    return datapoint

  datapoint = user_input();

  for i in numeric:
    path = r'scaler'+i+'.pkl'
    scaler  =  load(open(path, 'rb'))
    datapoint[i] = scaler.transform(datapoint[i].values.astype(np.float32).reshape(-1,1))

  for i in categoric:
    path    = r'encoder'+i+'.pkl'
    encoder =  load(open(path, 'rb'))
    datapoint[i] = encoder.transform(datapoint[i])

  st.subheader('Prediction')
  with st.spinner('Generating recommendation...'):

    time.sleep(5)
    if st.button('Predict'):
      st.snow()
      result = predict(datapoint)
      st.success(result)

if __name__ == '__main__':
    main()